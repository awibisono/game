<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>McKean–Vlasov Island Lab</title>

  <!-- MathJax (for the math panel) -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\(', '\)']],
        displayMath: [['$$', '$$'], ['\[', '\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --bg: #0f1116;
      --panel: rgba(18, 20, 28, 0.86);
      --border: rgba(255,255,255,0.14);
      --accent: #00bcd4;
      --accent2:#4fc3f7;
      --text: #e9eef5;
      --muted:#a9b3c2;
      --muted2:#7d8796;
      --shadow: 0 10px 30px rgba(0,0,0,0.55);
      --radius: 10px;
    }

    html, body{ height:100%; }
    body{
      margin:0;
      background: var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
      color: var(--text);
      user-select:none;
    }

    canvas#canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
      z-index: 1;
    }

    /* Panels (inspired by the user's provided reference UI) */
    #controls, #math-panel, #stats-panel{
      position:absolute;
      z-index:100;
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      pointer-events:auto;
    }

    #controls{
      top:14px;
      left:14px;
      width: 320px;
      max-height: 92vh;
      overflow:auto;
    }

    #math-panel{
      top:14px;
      right:14px;
      width: 420px;
      max-height: 62vh;
      overflow:auto;
    }

    #stats-panel{
      right:14px;
      bottom:14px;
      width: 420px;
      max-height: 30vh;
      overflow:auto;
    }

    .panelTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }

    .title{
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1.4px;
      color: var(--accent);
      font-weight: 750;
      margin: 0;
    }

    .iconBtn{
      width: 32px;
      height: 28px;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.82);
      cursor:pointer;
      font-weight: 800;
      padding:0;
    }
    .iconBtn:hover{ background: rgba(255,255,255,0.10); }

    h3{
      margin: 10px 0 8px 0;
      font-size: 14px;
      color: var(--accent2);
      font-weight: 750;
    }

    label{
      font-size: 13.5px;
      color: var(--muted);
      display:block;
      margin: 8px 0 6px 0;
    }

    select, input[type="number"], input[type="text"]{
      width: 100%;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px;
      padding: 8px 10px;
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }

    input[type="range"]{
      width:100%;
      margin: 4px 0 10px 0;
      cursor:pointer;
    }

    .row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }

    .btnrow{
      display:flex;
      gap:8px;
      margin-top:8px;
    }
    .btnrow button{ flex:1; margin-top:0 !important; }

    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      margin: 6px 0;
    }
    .toggle input{ cursor:pointer; }

    .divider{
      border:0;
      height:1px;
      background: rgba(255,255,255,0.12);
      margin: 12px 0;
    }

    button{
      width:100%;
      border:0;
      padding: 8px 10px;
      border-radius: 8px;
      cursor:pointer;
      background: #1f7ae0;
      color:white;
      font-weight: 700;
      margin-top: 6px;
    }
    button:hover{ background:#195fb0; }
    button.secondary{ background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.14); }
    button.secondary:hover{ background: rgba(255,255,255,0.14); }

    button.runBtn{ background:#1f7ae0; }
    button.runBtn:hover{ background:#195fb0; }
    button.runBtn.cta{ position: relative; animation: pulse 1.35s ease-in-out infinite; }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 0 rgba(31,122,224,0.55); transform: translateZ(0); }
      70%{ box-shadow: 0 0 0 12px rgba(31,122,224,0.00); }
      100%{ box-shadow: 0 0 0 0 rgba(31,122,224,0.00); }
    }

    button.stepBtn{ border: 1px solid rgba(255,255,255,0.22); background: rgba(255,255,255,0.10); }
    button.stepBtn:hover{ background: rgba(255,255,255,0.14); }

    details{
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.12);
      padding-top: 10px;
    }
    summary{
      cursor:pointer;
      color: var(--muted2);
      font-size: 13px;
      list-style:none;
      user-select:none;
    }
    summary:hover{ color: var(--muted); }

    .note{
      font-size: 13.5px;
      line-height: 1.35;
      color: rgba(255,255,255,0.75);
      margin-top: 6px;
    }

    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 4px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.86);
      font-size: 12.5px;
      font-weight: 650;
    }
    .dot{ width:9px; height:9px; border-radius:50%; display:inline-block; }

    /* Collapsing controls */
    .edgeTab{
      position: fixed;
      top: 14px;
      z-index: 110;
      display: none;
      width: auto !important;
      min-width: 0;
      max-width: 180px;
      height: 32px;
      align-items: center;
      justify-content: center;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      margin: 0;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      color: var(--text);
      cursor: pointer;
      font-size: 12.5px;
      font-weight: 650;
      letter-spacing: 0.2px;
      pointer-events:auto;
    }
    .edgeTab:hover{ background: rgba(255,255,255,0.08); }
    .edgeTab-left{ left: 12px; }
    .edgeTab-right{ right: 12px; }

    /* Footer */
    #footer{
      position: fixed;
      left: 14px;
      bottom: 12px;
      z-index: 90;
      font-size: 12.5px;
      color: rgba(255,255,255,0.65);
      pointer-events:auto;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(8px);
    }
    #footer a{ color: rgba(79,195,247,0.95); text-decoration: none; font-weight: 650; }
    #footer a:hover{ text-decoration: underline; }
    #controls a.inlineLink{ color: rgba(79,195,247,0.95); text-decoration: none; font-weight: 650; }
    #controls a.inlineLink:hover{ text-decoration: underline; }


    /* Small charts */
    .chartRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
    .chartCard{
      flex: 1 1 190px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px;
    }
    .chartTitle{ font-size: 12.5px; color: rgba(255,255,255,0.80); margin-bottom:6px; font-weight:700; }
    canvas.spark{ width:100%; height:70px; display:block; border-radius:10px; background: rgba(0,0,0,0.18); }

    /* Tooltip */
    #hoverTip{
      position: fixed;
      z-index: 120;
      pointer-events:none;
      transform: translate(12px, 12px);
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.16);
      color: rgba(255,255,255,0.88);
      font-size: 12.5px;
      display:none;
      max-width: 320px;
    }
    #hoverTip b{ color: rgba(79,195,247,0.95); }

  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div id="controls">
    <div class="panelTop">
      <div>
        <div class="title">McKean–Vlasov Island Lab</div>
        <div class="note" style="margin:6px 0 0 0;">30 creatures: 10 red, 10 green, 10 blue. A configurable fraction have a <b>rotational</b> (symplectic) mean-interaction.</div>
        <div class="note" style="margin:8px 0 0 0;"><a class="inlineLink" id="openMathLink" href="#math-panel">Open math & theory explanation</a></div>
      </div>
      <button id="toggleControlsBtn" class="iconBtn" title="Hide controls" aria-label="Hide controls">⟨</button>
    </div>

    <h3>Presets</h3>
    <label>Scenario</label>
    <select id="presetSelect"></select>
    <button id="loadPresetBtn" class="secondary">Load preset</button>

    <div class="divider"></div>

    <h3>Dynamics</h3>

    <label>Time step \(\Delta t\): <span id="dtVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.02</span></label>
    <input type="range" id="dtRange" min="0.005" max="0.08" step="0.001" value="0.02" />

    <label>Type attraction strength \(k\): <span id="kVal" style="color:rgba(255,255,255,0.86);font-weight:650;">1.00</span></label>
    <input type="range" id="kRange" min="0" max="3" step="0.01" value="1" />

    <label>Mean contraction (contractors) \(\alpha_c\): <span id="aCVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.60</span></label>
    <input type="range" id="aCRange" min="0" max="3" step="0.01" value="0.60" />

    <label>Mean contraction (rotators) \(\alpha_r\): <span id="aRVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.20</span></label>
    <input type="range" id="aRRange" min="0" max="3" step="0.01" value="0.20" />

    <label>Mean rotation (rotators) \(\beta\): <span id="bVal" style="color:rgba(255,255,255,0.86);font-weight:650;">2.20</span></label>
    <input type="range" id="bRange" min="0" max="8" step="0.01" value="2.20" />

    <label>Rotational fraction: <span id="rotFracVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.20</span></label>
    <input type="range" id="rotFracRange" min="0" max="1" step="0.01" value="0.20" />

    <label>Noise \(\sigma\): <span id="sigVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.05</span></label>
    <input type="range" id="sigRange" min="0" max="0.6" step="0.005" value="0.05" />

    <label>Terrain push (stay on land): <span id="shoreVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.80</span></label>
    <input type="range" id="shoreRange" min="0" max="3" step="0.01" value="0.80" />

    <div class="divider"></div>

    <h3>Extra interactions</h3>

    <div class="toggle"><input id="rpsOn" type="checkbox" /> <label style="margin:0;">Enable rock–paper–scissors mean-field coupling</label></div>
    <label>RPS strength \(\gamma\): <span id="gammaVal" style="color:rgba(255,255,255,0.86);font-weight:650;">1.20</span></label>
    <input type="range" id="gammaRange" min="0" max="6" step="0.01" value="1.20" />

    <div class="toggle"><input id="ecoOn" type="checkbox" checked /> <label style="margin:0;">Enable ecology attraction (terrain-dependent potentials)</label></div>
    <label>Ecology strength \(\eta\): <span id="ecoVal" style="color:rgba(255,255,255,0.86);font-weight:650;">0.90</span></label>
    <input type="range" id="ecoRange" min="0" max="4" step="0.01" value="0.90" />


    <div class="divider"></div>

    <h3>Initialize</h3>
    <label>Spawn</label>
    <select id="initSelect">
      <option value="center">All near island center</option>
      <option value="types">Near each type center</option>
      <option value="random">Random on land</option>
    </select>

    <div class="btnrow">
      <button id="resetBtn" class="secondary">Reset</button>
      <button id="reseedBtn" class="secondary">Reseed island</button>
    </div>

    <div class="divider"></div>

    <h3>Run</h3>
    <div class="btnrow">
      <button id="stepBtn" class="stepBtn">Step</button>
      <button id="runBtn" class="runBtn cta">Run</button>
    </div>

    <div class="row" style="margin-top:10px; gap:10px;">
      <span class="pill"><span class="dot" style="background:#ff5252;"></span> Red</span>
      <span class="pill"><span class="dot" style="background:#4fc3f7;"></span> Blue</span>
      <span class="pill"><span class="dot" style="background:#66bb6a;"></span> Green</span>
    </div>

    <div class="divider"></div>

    <h3>Overlays</h3>
    <div class="toggle"><input id="showContours" type="checkbox" checked /> <label style="margin:0;">Show type contours (quadratic wells)</label></div>
    <div class="toggle"><input id="showField" type="checkbox" checked /> <label style="margin:0;">Show vector field (selected)</label></div>
    <label>Vector field for</label>
    <select id="fieldSelect">
      <option value="red">Red creature (effective drift)</option>
      <option value="green">Green creature (effective drift)</option>
      <option value="blue">Blue creature (effective drift)</option>
      <option value="contractor">Contractor (mean + type)</option>
      <option value="rotator">Rotator (mean + type)</option>
    </select>

    <div class="toggle"><input id="showTrails" type="checkbox" checked /> <label style="margin:0;">Show short trails</label></div>
    <div class="toggle"><input id="showCenters" type="checkbox" checked /> <label style="margin:0;">Show type centers & mean</label></div>

    <details open>
      <summary>How to use</summary>
      <div class="note">
        Start paused. Click <b>Run</b> to animate. Use presets to illustrate: clustering vs consensus, spiral convergence due to \(\beta J\), or (near) pure rotation rings when \(\alpha_r \approx 0\) and \(k\) is small.
      </div>
    </details>

    <details>
      <summary>Lore (optional)</summary>
      <div class="note">
        <b>Triskelion Isle</b> is an island where three clans—Ember (red), Tide (blue), and Grove (green)—each feel a pull toward their ancestral landmark,
        yet they also sense the crowd’s collective drift. A few wanderers are born with a <i>spiral instinct</i>: they do not approach the crowd directly,
        but circle it, turning social alignment into motion.
      </div>
    </details>

  </div>

  <button id="controlsTab" class="edgeTab edgeTab-left">Show controls ⟩</button>

  <div id="math-panel">
    <div class="panelTop">
      <div class="title">Mathematical model</div>
      <button id="toggleMathBtn" class="iconBtn" title="Hide math" aria-label="Hide math">⟩</button>
    </div>

    <div class="note">
      This widget simulates a simple <b>interacting particle system</b> on a 2D island. Each creature \(i\in\{1,\dots,N\}\) has
      a position \(X^{(i)}_t\in\mathbb{R}^2\) and a type \(s(i)\in\{\mathrm{R},\mathrm{G},\mathrm{B}\}\}.
    </div>

    <div style="margin-top:10px;">
      $$\bar X_t := \frac{1}{N}\sum_{i=1}^N X^{(i)}_t\qquad\text{(empirical mean)}$$

      $$c_{\mathrm{R}}=(1,0),\quad c_{\mathrm{G}}=\Big(-\tfrac12,\tfrac{\sqrt3}{2}\Big),\quad c_{\mathrm{B}}=\Big(-\tfrac12,-\tfrac{\sqrt3}{2}\Big)$$

      $$J := \begin{pmatrix}0 & -1\\ 1 & 0\end{pmatrix}\qquad\text{(a 90° symplectic/rotation matrix)}$$

      <div class="divider"></div>

      <h3>Stochastic dynamics</h3>
      <div class="note">
        We simulate the SDE (Euler–Maruyama discretization):
      </div>
      <div id="odeEq" style="margin-top:8px;"></div>

      <div class="note">
        Contractors have \((\alpha_i,\beta_i)=(\alpha_c,0)\). Rotators have \((\alpha_i,\beta_i)=(\alpha_r,\beta)\).
        The \(\beta J\) term is <b>skew-symmetric</b>, so it creates tangential motion around the mean but (by itself) does not decrease distances.
      </div>

      <div class="divider"></div>

      <h3>Mean and variance (homogeneous coupling)</h3>
      <div class="note">
        If all particles share the same \(\alpha\) and \(\beta\) (a clean analytic baseline), then
        \(\beta J\) does not affect stability, and the system is linear with a unique equilibrium.
      </div>

      $$\dot{\bar X}_t = -k\,(\bar X_t - \bar c)\qquad \text{where}\quad \bar c := \frac{1}{N}\sum_{i=1}^N c_{s(i)}.$$

      <div class="note">
        Hence \(\bar X_t\to \bar c\) exponentially at rate \(k\). Define the empirical variance around the mean:
      </div>

      $$V_t := \frac{1}{N}\sum_{i=1}^N\|X^{(i)}_t-\bar X_t\|^2.$$

      <div class="note">
        Ignoring noise (\(\sigma=0\)), one can show:
      </div>

      $$\dot V_t = -2(k+\alpha)\,V_t\; +\; 2k\,\underbrace{\frac{1}{N}\sum_{i=1}^N\|c_{s(i)}-\bar c\|^2}_{\text{variance of type-centers}}.$$

      <div class="note">
        The \(\beta J\) term drops out because \(u\cdot (Ju)=0\). Consequently, \(V_t\) converges to a steady level that shrinks as \(\alpha\) increases:
      </div>

      $$V_\infty = \frac{k}{k+\alpha}\,\frac{1}{N}\sum_{i=1}^N\|c_{s(i)}-\bar c\|^2.$$

      <div class="divider"></div>

      <h3>Can we get sustained rotation?</h3>
      <div class="note">
        In this linear model, <b>stable</b> limit cycles do not occur. What you can see instead:
        <ul>
          <li><b>Spiral transients</b> when \(\alpha_r>0\) and \(\beta>0\): rotators circle while still contracting.</li>
          <li><b>Neutral rings</b> when a subgroup has (approximately) \(k\approx 0\) and \(\alpha_r\approx 0\) but \(\beta>0\): radii remain nearly constant, so they keep orbiting around \(\bar X_t\).</li>
          <li>With noise, these rings become <b>metastable</b> clouds whose radii fluctuate.</li>
        </ul>
      </div>
    </div>

  </div>

  <button id="mathTab" class="edgeTab edgeTab-right">Show math ⟨</button>

  <div id="stats-panel">
    <div class="panelTop">
      <div>
        <div class="title">Summary statistics</div>
        <div class="note" style="margin:6px 0 0 0;">Updated live while running. Curves show recent history (fixed window).</div>
      </div>
      <button id="toggleStatsBtn" class="iconBtn" title="Hide stats" aria-label="Hide stats">⟩</button>
    </div>

    <div class="row" style="gap:10px; flex-wrap:wrap;">
      <span class="pill"><span class="dot" style="background:rgba(255,255,255,0.85);"></span> t = <span id="tLabel">0.00</span></span>
      <span class="pill"><span class="dot" style="background:rgba(79,195,247,0.9);"></span> |mean| = <span id="meanNormLabel">0.00</span></span>
      <span class="pill"><span class="dot" style="background:rgba(255,193,7,0.9);"></span> V = <span id="varLabel">0.00</span></span>
    </div>

    <div class="chartRow">
      <div class="chartCard">
        <div class="chartTitle">Variance around mean \(V_t\)</div>
        <canvas id="chartVar" class="spark" width="560" height="140"></canvas>
      </div>
      <div class="chartCard">
        <div class="chartTitle">Mean distance to own type center</div>
        <canvas id="chartType" class="spark" width="560" height="140"></canvas>
      </div>
      <div class="chartCard">
        <div class="chartTitle">Rotators: mean radius \(\|X-\bar X\|\)</div>
        <canvas id="chartRot" class="spark" width="560" height="140"></canvas>
      </div>
      <div class="chartCard">
        <div class="chartTitle">Contractors: mean radius \(\|X-\bar X\|\)</div>
        <canvas id="chartCon" class="spark" width="560" height="140"></canvas>
      </div>
    </div>
  </div>

  <div id="hoverTip"></div>

  <div id="footer">&copy; <a href="https://awibisono.github.io" target="_blank" rel="noopener">Andre Wibisono</a> 2026</div>

<script>
(() => {
  'use strict';

  // ---------- Utilities ----------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  // Deterministic RNG (mulberry32)
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }

  // Gaussian via Box-Muller
  function randn(rng){
    let u = 0, v = 0;
    while(u === 0) u = rng();
    while(v === 0) v = rng();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  // 2D value noise (hash grid + smooth interpolation)
  function smoothstep(t){ return t*t*(3 - 2*t); }
  function smoothstepAB(a,b,x){
    if(a===b) return x>=b ? 1 : 0;
    const t = clamp((x-a)/(b-a), 0, 1);
    return smoothstep(t);
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function hash2i(ix, iy, seed){
    // integer hash -> [0,1)
    let h = ix * 374761393 + iy * 668265263 + seed * 1442695041;
    h = (h ^ (h >>> 13)) * 1274126177;
    h = h ^ (h >>> 16);
    return (h >>> 0) / 4294967296;
  }
  function valueNoise(x, y, freq, seed){
    const xf = x * freq;
    const yf = y * freq;
    const x0 = Math.floor(xf), y0 = Math.floor(yf);
    const tx = smoothstep(xf - x0);
    const ty = smoothstep(yf - y0);
    const v00 = hash2i(x0, y0, seed);
    const v10 = hash2i(x0+1, y0, seed);
    const v01 = hash2i(x0, y0+1, seed);
    const v11 = hash2i(x0+1, y0+1, seed);
    const vx0 = lerp(v00, v10, tx);
    const vx1 = lerp(v01, v11, tx);
    return lerp(vx0, vx1, ty);
  }

  function fbm(x,y,seed){
    // 4-octave fBm in [0,1]
    let amp = 0.55;
    let freq = 1.0;
    let sum = 0.0;
    let norm = 0.0;
    for(let o=0;o<4;o++){
      sum += amp * valueNoise(x, y, 1.8*freq, seed + 101*o);
      norm += amp;
      amp *= 0.55;
      freq *= 2.0;
    }
    return sum / norm;
  }

  // ---------- Canvas / coordinate system ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  let W = 1, H = 1, DPR = 1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    regenBackground();
  }
  window.addEventListener('resize', resize);

  // World box
  const WORLD = {
    xmin: -1.75,
    xmax:  1.75,
    ymin: -1.75,
    ymax:  1.75
  };

  function worldToScreen(x,y){
    const sx = (x - WORLD.xmin) / (WORLD.xmax - WORLD.xmin) * W;
    const sy = (1 - (y - WORLD.ymin) / (WORLD.ymax - WORLD.ymin)) * H;
    return [sx, sy];
  }
  function screenToWorld(sx,sy){
    const x = WORLD.xmin + (sx / W) * (WORLD.xmax - WORLD.xmin);
    const y = WORLD.ymin + (1 - sy / H) * (WORLD.ymax - WORLD.ymin);
    return [x, y];
  }

  // ---------- Island terrain field ----------
  let islandSeed = 1337;

  function islandMask(x,y){
    // radial falloff + noise; returns approx in [0,1]
    const r = Math.sqrt(x*x + y*y) / 1.75;
    const base = Math.exp(-2.7 * r*r);
    const n = fbm(x*0.85 + 1.7, y*0.85 - 0.9, islandSeed);
    const ridge = fbm(x*1.6 - 0.3, y*1.6 + 0.4, islandSeed + 777);
    let m = 0.72*base + 0.20*(n - 0.5) + 0.10*(ridge - 0.5);
    // make coastline sharper
    m = 1/(1 + Math.exp(-7.0*(m - 0.38)));
    return clamp(m, 0, 1);
  }


  function lakeMask(x,y,m){
    // soft lake indicator in [0,1] (interior water patches)
    if(m < 0.50) return 0;
    const n1 = fbm(x*2.35 + 6.1, y*2.35 - 3.7, islandSeed + 91919);
    const n2 = fbm(x*4.60 - 2.2, y*4.60 + 1.5, islandSeed + 12345);
    const raw = 0.75*n1 + 0.25*n2;
    const lake = smoothstepAB(0.74, 0.86, raw) * smoothstepAB(0.52, 0.86, m);
    return clamp(lake, 0, 1);
  }

  
  function terrainColor(m, x, y){
    // biome based on mask + extra noise (plus interior lakes)
    const waterLine = 0.42;
    const beachLine = 0.48;
    const forestLine = 0.62;
    const mountainLine = 0.80;

    const moist = fbm(x*1.2 + 3.1, y*1.2 - 2.7, islandSeed + 2024);
    const lk = lakeMask(x, y, m);

    // ocean
    if(m < waterLine){
      const d = clamp((waterLine - m)/waterLine, 0, 1);
      const c1 = [5, 18, 38];
      const c2 = [10, 70, 110];
      const t = 1 - d*d;
      return [
        Math.floor(lerp(c1[0], c2[0], t)),
        Math.floor(lerp(c1[1], c2[1], t)),
        Math.floor(lerp(c1[2], c2[2], t))
      ];
    }

    // beach
    if(m < beachLine){
      const t = (m - waterLine) / (beachLine - waterLine);
      const c1 = [180, 162, 106];
      const c2 = [224, 206, 140];
      return [
        Math.floor(lerp(c1[0], c2[0], t)),
        Math.floor(lerp(c1[1], c2[1], t)),
        Math.floor(lerp(c1[2], c2[2], t))
      ];
    }

    // interior lakes (only on land)
    if(lk > 0.55 && m > beachLine){
      const t = clamp((lk - 0.55) / (1 - 0.55), 0, 1);
      const c1 = [16, 82, 128];
      const c2 = [34, 152, 198];
      return [
        Math.floor(lerp(c1[0], c2[0], t)),
        Math.floor(lerp(c1[1], c2[1], t)),
        Math.floor(lerp(c1[2], c2[2], t))
      ];
    }

    // grass
    if(m < forestLine){
      const t = (m - beachLine) / (forestLine - beachLine);
      const c1 = [55, 118, 62];
      const c2 = [74, 168, 86];
      const g = lerp(0.9, 1.1, moist);
      return [
        Math.floor(clamp(lerp(c1[0], c2[0], t)*g, 0, 255)),
        Math.floor(clamp(lerp(c1[1], c2[1], t)*g, 0, 255)),
        Math.floor(clamp(lerp(c1[2], c2[2], t)*g, 0, 255))
      ];
    }

    // forest
    if(m < mountainLine){
      const t = (m - forestLine) / (mountainLine - forestLine);
      const c1 = [35, 78, 44];
      const c2 = [48, 112, 60];
      const g = lerp(0.95, 1.07, moist);
      return [
        Math.floor(clamp(lerp(c1[0], c2[0], t)*g, 0, 255)),
        Math.floor(clamp(lerp(c1[1], c2[1], t)*g, 0, 255)),
        Math.floor(clamp(lerp(c1[2], c2[2], t)*g, 0, 255))
      ];
    }

    // mountaintop
    {
      const t = (m - mountainLine) / (1 - mountainLine);
      const c1 = [130, 132, 138];
      const c2 = [216, 220, 230];
      return [
        Math.floor(lerp(c1[0], c2[0], t)),
        Math.floor(lerp(c1[1], c2[1], t)),
        Math.floor(lerp(c1[2], c2[2], t))
      ];
    }
  }

  // Background cache

  const bgCanvas = document.createElement('canvas');
  const bgCtx = bgCanvas.getContext('2d');

  function regenBackground(){
    bgCanvas.width = W;
    bgCanvas.height = H;

    // paint terrain by sampling world grid
    const img = bgCtx.createImageData(W, H);
    const data = img.data;

    // sample at reduced resolution for speed, then scale (simple nearest)
    const step = Math.max(1, Math.floor(DPR * 2));

    for(let sy=0; sy<H; sy+=step){
      for(let sx=0; sx<W; sx+=step){
        const [x,y] = screenToWorld(sx, sy);
        const m = islandMask(x,y);
        const c = terrainColor(m, x, y);

        for(let yy=0; yy<step; yy++){
          const ry = sy + yy;
          if(ry >= H) break;
          for(let xx=0; xx<step; xx++){
            const rx = sx + xx;
            if(rx >= W) break;
            const idx = 4*(ry*W + rx);
            data[idx] = c[0];
            data[idx+1] = c[1];
            data[idx+2] = c[2];
            data[idx+3] = 255;
          }
        }
      }
    }

    bgCtx.putImageData(img, 0, 0);

    // add subtle vignette
    const grd = bgCtx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.15, W*0.5, H*0.5, Math.max(W,H)*0.65);
    grd.addColorStop(0, 'rgba(0,0,0,0)');
    grd.addColorStop(1, 'rgba(0,0,0,0.55)');
    bgCtx.fillStyle = grd;
    bgCtx.fillRect(0,0,W,H);

    // Ecology fields depend on the terrain seed, so refresh them here.
    precomputeEcoGrid();
  }

  // ---------- Particle system ----------
  const N = 30;
  const TYPES = ['red','green','blue'];
  const typeColor = {
    red:   { fill:'#ff5252', stroke:'rgba(255,82,82,0.55)' },
    green: { fill:'#66bb6a', stroke:'rgba(102,187,106,0.55)' },
    blue:  { fill:'#4fc3f7', stroke:'rgba(79,195,247,0.55)' }
  };

  const centers = {
    red:   { x:  1.00, y:  0.00 },
    green: { x: -0.50, y:  Math.sqrt(3)/2 },
    blue:  { x: -0.50, y: -Math.sqrt(3)/2 }
  };

  let rng = mulberry32(424242);

  function sampleOnLand(){
    for(let tries=0; tries<4000; tries++){
      const x = lerp(WORLD.xmin, WORLD.xmax, rng());
      const y = lerp(WORLD.ymin, WORLD.ymax, rng());
      if(islandMask(x,y) > 0.47) return {x,y};
    }
    // fallback
    return {x:0,y:0};
  }

  let particles = [];

  function assignRoles(rotFrac){
    // random subset flagged rotational
    const idx = [...Array(N)].map((_,i)=>i);
    for(let i=idx.length-1;i>0;i--){
      const j = Math.floor(rng()*(i+1));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    const K = Math.round(rotFrac * N);
    const rotSet = new Set(idx.slice(0, K));
    particles.forEach((p, i) => { p.isRot = rotSet.has(i); });
  }

  function resetParticles(mode){
    particles = [];
    // 10 per type
    const order = [];
    for(const t of TYPES){ for(let i=0;i<10;i++) order.push(t); }

    // shuffle
    for(let i=order.length-1;i>0;i--){
      const j = Math.floor(rng()*(i+1));
      [order[i], order[j]] = [order[j], order[i]];
    }

    for(let i=0;i<N;i++){
      const type = order[i];
      let x=0,y=0;
      if(mode === 'center'){
        x = 0.05*randn(rng);
        y = 0.05*randn(rng);
      } else if(mode === 'types'){
        const c = centers[type];
        x = c.x + 0.10*randn(rng);
        y = c.y + 0.10*randn(rng);
      } else {
        const s = sampleOnLand();
        x = s.x; y = s.y;
      }

      // snap toward land if needed
      if(islandMask(x,y) < 0.40){
        const s = sampleOnLand();
        x = s.x; y = s.y;
      }

      particles.push({
        x, y,
        type,
        isRot: false,
        trail: []
      });
    }

    assignRoles(getParams().rotFrac);
    t = 0;
    stepCount = 0;
    clearStats();
  }

  function meanPosition(){
    let mx=0,my=0;
    for(const p of particles){ mx += p.x; my += p.y; }
    return { x: mx / N, y: my / N };
  }


  function meanByType(){
    const sums = { red:{x:0,y:0,c:0}, green:{x:0,y:0,c:0}, blue:{x:0,y:0,c:0} };
    for(const p of particles){
      const s = sums[p.type];
      s.x += p.x; s.y += p.y; s.c += 1;
    }
    const out = {};
    for(const k of ['red','green','blue']){
      const s = sums[k];
      out[k] = s.c ? {x: s.x/s.c, y: s.y/s.c} : {x:0,y:0};
    }
    return out;
  }

  function Jmul(vx, vy){
    // J [vx,vy] = [-vy, vx]
    return { x: -vy, y: vx };
  }

  function terrainPush(x,y, shore){
    if(shore <= 0) return {x:0, y:0};
    const waterLine = 0.44;
    const m = islandMask(x,y);
    if(m >= waterLine) return {x:0, y:0};

    // approximate grad(mask) by finite differences
    const eps = 0.006;
    const mx1 = islandMask(x+eps, y);
    const mx0 = islandMask(x-eps, y);
    const my1 = islandMask(x, y+eps);
    const my0 = islandMask(x, y-eps);
    const gx = (mx1 - mx0) / (2*eps);
    const gy = (my1 - my0) / (2*eps);

    // push inward proportional to how deep in water we are
    const depth = clamp((waterLine - m) / waterLine, 0, 1);
    const s = shore * (0.6 + 1.8*depth);
    return { x: s*gx, y: s*gy };
  }


  // ---------- Optional ecology (terrain-dependent potentials) ----------
  // For accessibility/performance, we precompute ∇Φ_s on a coarse grid when the island is (re)generated.
  // Then each particle samples the gradient via bilinear interpolation during simulation.

  let ecoGrid = null;

  function ecoPhi(type, x, y){
    // scalar field in [0,1] that each type prefers
    // red: beach band near shoreline
    // green: higher elevation forest
    // blue: interior lakes
    const m = islandMask(x, y);
    const moist = fbm(x*1.2 + 3.1, y*1.2 - 2.7, islandSeed + 2024);
    const lk = lakeMask(x, y, m);

    const waterLine = 0.42;
    const beachLine = 0.48;
    const forestLine = 0.62;
    const mountainLine = 0.80;

    const beachBand = smoothstepAB(waterLine, beachLine, m) * (1 - smoothstepAB(beachLine, forestLine, m));
    const forest = smoothstepAB(forestLine, mountainLine, m) * (0.65 + 0.35*moist);
    const lake = lk;

    if(type === 'red') return beachBand;
    if(type === 'green') return forest;
    return lake;
  }

  function precomputeEcoGrid(){
    const GX = 140;
    const GY = 140;
    const xmin = WORLD.xmin, xmax = WORLD.xmax;
    const ymin = WORLD.ymin, ymax = WORLD.ymax;
    const dx = (xmax - xmin) / (GX - 1);
    const dy = (ymax - ymin) / (GY - 1);

    const phiR = new Float32Array(GX*GY);
    const phiG = new Float32Array(GX*GY);
    const phiB = new Float32Array(GX*GY);

    for(let j=0; j<GY; j++){
      const y = ymin + j*dy;
      for(let i=0; i<GX; i++){
        const x = xmin + i*dx;
        const idx = j*GX + i;
        phiR[idx] = ecoPhi('red', x, y);
        phiG[idx] = ecoPhi('green', x, y);
        phiB[idx] = ecoPhi('blue', x, y);
      }
    }

    function gradFromPhi(phi){
      const gx = new Float32Array(GX*GY);
      const gy = new Float32Array(GX*GY);
      for(let j=0; j<GY; j++){
        for(let i=0; i<GX; i++){
          const idx = j*GX + i;
          const im1 = (i>0) ? i-1 : i;
          const ip1 = (i<GX-1) ? i+1 : i;
          const jm1 = (j>0) ? j-1 : j;
          const jp1 = (j<GY-1) ? j+1 : j;
          const fx1 = phi[j*GX + ip1];
          const fx0 = phi[j*GX + im1];
          const fy1 = phi[jp1*GX + i];
          const fy0 = phi[jm1*GX + i];
          const ddx = (ip1-im1) * dx;
          const ddy = (jp1-jm1) * dy;
          gx[idx] = (fx1 - fx0) / (ddx || dx);
          gy[idx] = (fy1 - fy0) / (ddy || dy);
        }
      }
      return {gx, gy};
    }

    const gR = gradFromPhi(phiR);
    const gG = gradFromPhi(phiG);
    const gB = gradFromPhi(phiB);

    ecoGrid = { GX, GY, xmin, ymin, dx, dy, gR, gG, gB };
  }

  function sampleEcoGrad(type, x, y){
    if(!ecoGrid) return {x:0, y:0};
    const { GX, GY, xmin, ymin, dx, dy } = ecoGrid;

    // fractional grid coords
    let fx = (x - xmin) / dx;
    let fy = (y - ymin) / dy;

    // clamp
    fx = clamp(fx, 0, GX-1);
    fy = clamp(fy, 0, GY-1);

    const x0 = Math.floor(fx), y0 = Math.floor(fy);
    const x1 = Math.min(x0 + 1, GX-1);
    const y1 = Math.min(y0 + 1, GY-1);
    const tx = fx - x0;
    const ty = fy - y0;

    let g;
    if(type === 'red') g = ecoGrid.gR;
    else if(type === 'green') g = ecoGrid.gG;
    else g = ecoGrid.gB;

    const i00 = y0*GX + x0;
    const i10 = y0*GX + x1;
    const i01 = y1*GX + x0;
    const i11 = y1*GX + x1;

    const gx0 = lerp(g.gx[i00], g.gx[i10], tx);
    const gx1 = lerp(g.gx[i01], g.gx[i11], tx);
    const gy0 = lerp(g.gy[i00], g.gy[i10], tx);
    const gy1 = lerp(g.gy[i01], g.gy[i11], ty);

    return { x: lerp(gx0, gx1, ty), y: lerp(gy0, gy1, ty) };
  }

  // Keep these names so the rest of the code can stay simple.
  function gradEco(type, x, y){
    return sampleEcoGrad(type, x, y);
  }

  // ---------- Optional rock–paper–scissors (RPS) mean-field coupling ----------
  // Using an antisymmetric matrix A on type means: (R,G,B) -> (B-G, R-B, G-R)
  function rpsDrift(type, means, gamma){
    if(gamma === 0) return {x:0, y:0};
    const r = means.red, g = means.green, b = means.blue;
    if(type === 'red')   return { x: gamma*(b.x - g.x), y: gamma*(b.y - g.y) };
    if(type === 'green') return { x: gamma*(r.x - b.x), y: gamma*(r.y - b.y) };
    return { x: gamma*(g.x - r.x), y: gamma*(g.y - r.y) }; // blue
  }

  // ---------- Parameters and presets ----------
  const ui = {
    dtRange: document.getElementById('dtRange'),
    kRange: document.getElementById('kRange'),
    aCRange: document.getElementById('aCRange'),
    aRRange: document.getElementById('aRRange'),
    bRange: document.getElementById('bRange'),
    rotFracRange: document.getElementById('rotFracRange'),
    sigRange: document.getElementById('sigRange'),
    shoreRange: document.getElementById('shoreRange'),

    rpsOn: document.getElementById('rpsOn'),
    gammaRange: document.getElementById('gammaRange'),
    ecoOn: document.getElementById('ecoOn'),
    ecoRange: document.getElementById('ecoRange'),

    dtVal: document.getElementById('dtVal'),
    kVal: document.getElementById('kVal'),
    aCVal: document.getElementById('aCVal'),
    aRVal: document.getElementById('aRVal'),
    bVal: document.getElementById('bVal'),
    rotFracVal: document.getElementById('rotFracVal'),
    sigVal: document.getElementById('sigVal'),
    shoreVal: document.getElementById('shoreVal'),

    gammaVal: document.getElementById('gammaVal'),
    ecoVal: document.getElementById('ecoVal'),

    odeEq: document.getElementById('odeEq'),

    initSelect: document.getElementById('initSelect'),
    resetBtn: document.getElementById('resetBtn'),
    reseedBtn: document.getElementById('reseedBtn'),

    runBtn: document.getElementById('runBtn'),
    stepBtn: document.getElementById('stepBtn'),

    showContours: document.getElementById('showContours'),
    showField: document.getElementById('showField'),
    showTrails: document.getElementById('showTrails'),
    showCenters: document.getElementById('showCenters'),
    fieldSelect: document.getElementById('fieldSelect'),

    presetSelect: document.getElementById('presetSelect'),
    loadPresetBtn: document.getElementById('loadPresetBtn'),

    tLabel: document.getElementById('tLabel'),
    meanNormLabel: document.getElementById('meanNormLabel'),
    varLabel: document.getElementById('varLabel'),

    chartVar: document.getElementById('chartVar'),
    chartType: document.getElementById('chartType'),
    chartRot: document.getElementById('chartRot'),
    chartCon: document.getElementById('chartCon'),

    hoverTip: document.getElementById('hoverTip')
  };

  function getParams(){
    return {
      dt: parseFloat(ui.dtRange.value),
      k: parseFloat(ui.kRange.value),
      alphaC: parseFloat(ui.aCRange.value),
      alphaR: parseFloat(ui.aRRange.value),
      beta: parseFloat(ui.bRange.value),
      rotFrac: parseFloat(ui.rotFracRange.value),
      sigma: parseFloat(ui.sigRange.value),
      shore: parseFloat(ui.shoreRange.value),
      rpsOn: !!ui.rpsOn.checked,
      gamma: parseFloat(ui.gammaRange.value),
      ecoOn: !!ui.ecoOn.checked,
      eco: parseFloat(ui.ecoRange.value)
    };
  }

  function syncLabels(){
    ui.dtVal.textContent = (+ui.dtRange.value).toFixed(3);
    ui.kVal.textContent = (+ui.kRange.value).toFixed(2);
    ui.aCVal.textContent = (+ui.aCRange.value).toFixed(2);
    ui.aRVal.textContent = (+ui.aRRange.value).toFixed(2);
    ui.bVal.textContent = (+ui.bRange.value).toFixed(2);
    ui.rotFracVal.textContent = (+ui.rotFracRange.value).toFixed(2);
    ui.sigVal.textContent = (+ui.sigRange.value).toFixed(3);
    ui.shoreVal.textContent = (+ui.shoreRange.value).toFixed(2);
    ui.gammaVal.textContent = (+ui.gammaRange.value).toFixed(2);
    ui.ecoVal.textContent = (+ui.ecoRange.value).toFixed(2);
  }

  function buildOdeLatex(params){
    // Build a LaTeX string reflecting the currently simulated SDE.
    const terms = [];

    terms.push(`-k\,(X_t^{(i)}-c_{s(i)})`);
    terms.push(`-\alpha_i\,(X_t^{(i)}-\bar X_t)`);
    terms.push(`+\beta_i J\,(X_t^{(i)}-\bar X_t)`);

    if(params.rpsOn && params.gamma > 0){
      terms.push(`+\gamma\,\sum_{s'\in\{\mathrm{R},\mathrm{G},\mathrm{B}\}} A_{s(i),s'}\,\bar X_t^{s'}`);
    }

    if(params.ecoOn && params.eco > 0){
      terms.push(`+\eta\,\nabla\Phi_{s(i)}(X_t^{(i)})`);
    }

    if(params.shore > 0){
      terms.push(`+u_\text{shore}(X_t^{(i)})`);
    }

    const drift = terms.join('\,\');

    let expl = '';
    if(params.rpsOn && params.gamma > 0){
      expl += `\\textbf{RPS:}\,A\text{ is antisymmetric and }(\bar X^\mathrm{R},\bar X^\mathrm{G},\bar X^\mathrm{B})\mapsto(\bar X^\mathrm{B}-\bar X^\mathrm{G},\bar X^\mathrm{R}-\bar X^\mathrm{B},\bar X^\mathrm{G}-\bar X^\mathrm{R}).\\`;
    }
    if(params.ecoOn && params.eco > 0){
      expl += `\\textbf{Ecology:}\,\Phi_\mathrm{R}=\text{beach band},\;\Phi_\mathrm{G}=\text{forest elevation},\;\Phi_\mathrm{B}=\text{lake intensity}.`;
    }

    return `\[\mathrm{d}X_t^{(i)} = \Big(${drift}\Big)\,\mathrm{d}t \; +\; \sigma\,\mathrm{d}W_t^{(i)}. \]${expl ? `\[${expl}\]` : ''}`;
  }

  function updateMathEquation(){
    const params = getParams();
    if(!ui.odeEq) return;
    ui.odeEq.innerHTML = buildOdeLatex(params);
    if(window.MathJax && window.MathJax.typesetPromise){
      window.MathJax.typesetPromise([ui.odeEq]).catch(()=>{});
    }
  }

  
  [ui.dtRange, ui.kRange, ui.aCRange, ui.aRRange, ui.bRange, ui.rotFracRange, ui.sigRange, ui.shoreRange, ui.gammaRange, ui.ecoRange].forEach(el => {
    el.addEventListener('input', () => {
      syncLabels();
      if(el === ui.rotFracRange){
        assignRoles(getParams().rotFrac);
      }
      updateMathEquation();
    });
  });

  ui.rpsOn.addEventListener('change', () => updateMathEquation());
  ui.ecoOn.addEventListener('change', () => updateMathEquation());

  const PRESETS = [
    {
      id: 'p0',
      name: '0. Baseline clustering (3 wells)',
      desc: 'Small mean-coupling; creatures cluster near their type-centers.',
      params: { dt:0.02, k:1.2, alphaC:0.25, alphaR:0.25, beta:0.0, rotFrac:0.0, sigma:0.02, shore:0.8 },
      init: 'types'
    },
    {
      id: 'p1',
      name: '1. Consensus (strong coupling)',
      desc: 'Large mean contraction: all types collapse toward the common mean (near the average center).',
      params: { dt:0.02, k:1.0, alphaC:2.2, alphaR:2.2, beta:0.0, rotFrac:0.0, sigma:0.02, shore:0.8 },
      init: 'types'
    },
    {
      id: 'p2',
      name: '2. Spiral convergence (20% rotators)',
      desc: 'A minority has rotational mean-coupling; spirals appear but system remains contractive.',
      params: { dt:0.02, k:1.0, alphaC:0.6, alphaR:0.2, beta:2.2, rotFrac:0.2, sigma:0.05, shore:0.8 },
      init: 'center'
    },
    {
      id: 'p3',
      name: '3. Metastable rotating cloud (weak damping)',
      desc: 'Rotators are nearly undamped (alpha_r≈0) and the type-wells are weak: orbit-like patterns persist.',
      params: { dt:0.02, k:0.15, alphaC:0.25, alphaR:0.02, beta:4.5, rotFrac:0.35, sigma:0.03, shore:0.8 },
      init: 'center'
    },
    {
      id: 'p4',
      name: '4. Noisy mixing (explore stationary behavior)',
      desc: 'Noise competes with attraction: clouds form with visible fluctuations.',
      params: { dt:0.02, k:0.8, alphaC:1.0, alphaR:0.5, beta:2.2, rotFrac:0.2, sigma:0.25, shore:0.8 },
      init: 'random'
    }
    ,
    {
      id: 'p5',
      name: '5. RPS + ecology (population-level cycling)',
      desc: 'Rock–paper–scissors coupling rotates the three type-clusters while ecology pulls each type toward its preferred biome.',
      params: { dt:0.02, k:0.9, alphaC:0.55, alphaR:0.25, beta:1.6, rotFrac:0.2, sigma:0.05, shore:0.8, rpsOn:true, gamma:1.8, ecoOn:true, eco:1.0 },
      init: 'types'
    }
];

  function setParamSliders(p){
    ui.dtRange.value = p.dt;
    ui.kRange.value = p.k;
    ui.aCRange.value = p.alphaC;
    ui.aRRange.value = p.alphaR;
    ui.bRange.value = p.beta;
    ui.rotFracRange.value = p.rotFrac;
    ui.sigRange.value = p.sigma;
    ui.shoreRange.value = p.shore;
    ui.rpsOn.checked = ('rpsOn' in p) ? !!p.rpsOn : false;
    ui.gammaRange.value = ('gamma' in p) ? p.gamma : 1.20;
    ui.ecoOn.checked = ('ecoOn' in p) ? !!p.ecoOn : true;
    ui.ecoRange.value = ('eco' in p) ? p.eco : 0.90;
    syncLabels();
    assignRoles(getParams().rotFrac);
  }

  function populatePresets(){
    ui.presetSelect.innerHTML = '';
    for(const pr of PRESETS){
      const opt = document.createElement('option');
      opt.value = pr.id;
      opt.textContent = pr.name;
      ui.presetSelect.appendChild(opt);
    }
  }

  function loadPresetById(id){
    const pr = PRESETS.find(x => x.id === id) || PRESETS[0];
    setParamSliders(pr.params);
    ui.initSelect.value = pr.init;
    resetParticles(pr.init);
    running = false;
    ui.runBtn.textContent = 'Run';
    ui.runBtn.classList.add('cta');
    // Provide description in hoverTip briefly
    flashTip(`<b>${pr.name}</b><br>${pr.desc}`);
  }

  // ---------- Stats ----------
  const MAXHIST = 260;
  let histVar = [], histType = [], histRot = [], histCon = [];

  function pushHist(arr, v){
    arr.push(v);
    if(arr.length > MAXHIST) arr.shift();
  }

  function clearStats(){
    histVar = []; histType = []; histRot = []; histCon = [];
  }

  function drawSpark(canvasEl, arr){
    const c = canvasEl.getContext('2d');
    const w = canvasEl.width, h = canvasEl.height;
    c.clearRect(0,0,w,h);

    // background grid
    c.globalAlpha = 1;
    c.fillStyle = 'rgba(0,0,0,0.10)';
    c.fillRect(0,0,w,h);
    c.strokeStyle = 'rgba(255,255,255,0.10)';
    c.lineWidth = 1;
    for(let i=1;i<=4;i++){
      const y = i*h/5;
      c.beginPath(); c.moveTo(0,y); c.lineTo(w,y); c.stroke();
    }

    if(arr.length < 2) return;
    let minV = Infinity, maxV = -Infinity;
    for(const v of arr){ minV = Math.min(minV, v); maxV = Math.max(maxV, v); }
    if(maxV - minV < 1e-9){ maxV = minV + 1; }

    const pad = 6;
    c.strokeStyle = 'rgba(79,195,247,0.95)';
    c.lineWidth = 2;
    c.beginPath();
    for(let i=0;i<arr.length;i++){
      const x = pad + (w-2*pad) * (i/(arr.length-1));
      const y = h - pad - (h-2*pad) * ((arr[i]-minV)/(maxV-minV));
      if(i===0) c.moveTo(x,y); else c.lineTo(x,y);
    }
    c.stroke();

    // last value marker
    const lv = arr[arr.length-1];
    const lx = pad + (w-2*pad);
    const ly = h - pad - (h-2*pad) * ((lv-minV)/(maxV-minV));
    c.fillStyle = 'rgba(255,255,255,0.90)';
    c.beginPath(); c.arc(lx, ly, 3.2, 0, 2*Math.PI); c.fill();
  }

  // ---------- Simulation loop ----------
  let running = false;
  let t = 0;
  let stepCount = 0;

  
  function driftAt(x, y, type, role, mean, typeMeans, params){
    const c = centers[type];
    let fx = -params.k * (x - c.x);
    let fy = -params.k * (y - c.y);

    // mean interaction (with optional symplectic rotation for rotators)
    const dx = x - mean.x;
    const dy = y - mean.y;

    let alpha = params.alphaC;
    let beta = 0;
    if(role === 'rotator'){
      alpha = params.alphaR;
      beta = params.beta;
    }

    fx += -alpha * dx;
    fy += -alpha * dy;

    if(beta !== 0){
      const j = Jmul(dx, dy);
      fx += beta * j.x;
      fy += beta * j.y;
    }

    // Optional RPS mean-field coupling: adds type-dependent drift driven by (mu_R, mu_G, mu_B)
    if(params.rpsOn){
      const rr = rpsDrift(type, typeMeans, params.gamma);
      fx += rr.x;
      fy += rr.y;
    }

    // Optional ecology: each type climbs the gradient of its preferred terrain feature
    if(params.ecoOn && params.eco > 0){
      const g = gradEco(type, x, y);
      fx += params.eco * g.x;
      fy += params.eco * g.y;
    }

    // Keep creatures on land (push out of deep ocean)
    const shore = terrainPush(x, y, params.shore);
    fx += shore.x;
    fy += shore.y;

    return {x:fx, y:fy};
  }

  function stepOnce(){
    const params = getParams();
    const mean = meanPosition();
    const typeMeans = meanByType();

    // Euler-Maruyama
    const dt = params.dt;
    const sdt = Math.sqrt(dt);

    // stats accumulators
    let varAcc = 0;
    let typeAcc = 0;
    let rotAcc = 0, rotCnt = 0;
    let conAcc = 0, conCnt = 0;

    for(const p of particles){
      const role = p.isRot ? 'rotator' : 'contractor';
      const d = driftAt(p.x, p.y, p.type, role, mean, typeMeans, params);

      // noise
      const nx = params.sigma * sdt * randn(rng);
      const ny = params.sigma * sdt * randn(rng);

      p.x += dt * d.x + nx;
      p.y += dt * d.y + ny;

      // keep inside world box (reflect)
      if(p.x < WORLD.xmin){ p.x = WORLD.xmin + (WORLD.xmin - p.x); }
      if(p.x > WORLD.xmax){ p.x = WORLD.xmax - (p.x - WORLD.xmax); }
      if(p.y < WORLD.ymin){ p.y = WORLD.ymin + (WORLD.ymin - p.y); }
      if(p.y > WORLD.ymax){ p.y = WORLD.ymax - (p.y - WORLD.ymax); }

      // trail
      if(ui.showTrails.checked){
        p.trail.push({x:p.x, y:p.y});
        if(p.trail.length > 18) p.trail.shift();
      } else {
        p.trail = [];
      }

      // stats pieces
      const dxm = p.x - mean.x;
      const dym = p.y - mean.y;
      varAcc += dxm*dxm + dym*dym;

      const c = centers[p.type];
      const dxc = p.x - c.x;
      const dyc = p.y - c.y;
      typeAcc += Math.sqrt(dxc*dxc + dyc*dyc);

      const r = Math.sqrt(dxm*dxm + dym*dym);
      if(p.isRot){ rotAcc += r; rotCnt++; }
      else { conAcc += r; conCnt++; }
    }

    const V = varAcc / N;
    const meanTypeDist = typeAcc / N;
    const meanRotR = rotCnt ? (rotAcc/rotCnt) : 0;
    const meanConR = conCnt ? (conAcc/conCnt) : 0;

    pushHist(histVar, V);
    pushHist(histType, meanTypeDist);
    pushHist(histRot, meanRotR);
    pushHist(histCon, meanConR);

    t += dt;
    stepCount += 1;

    // update labels
    ui.tLabel.textContent = t.toFixed(2);
    const mn = Math.sqrt(mean.x*mean.x + mean.y*mean.y);
    ui.meanNormLabel.textContent = mn.toFixed(2);
    ui.varLabel.textContent = V.toFixed(3);

    // redraw charts
    drawSpark(ui.chartVar, histVar);
    drawSpark(ui.chartType, histType);
    drawSpark(ui.chartRot, histRot);
    drawSpark(ui.chartCon, histCon);
  }

  // ---------- Rendering ----------
  function drawContours(){
    // draw quadratic level sets around each type center
    ctx.save();
    ctx.globalAlpha = 0.55;

    const levels = [0.18, 0.32, 0.50, 0.72, 0.96, 1.25];
    for(const typ of TYPES){
      const c = centers[typ];
      const col = typeColor[typ].stroke;
      ctx.strokeStyle = col;
      ctx.lineWidth = 1.25 * DPR;

      for(const r of levels){
        const [sx, sy] = worldToScreen(c.x, c.y);
        // world radius -> screen
        const [sx2] = worldToScreen(c.x + r, c.y);
        const rad = Math.abs(sx2 - sx);
        ctx.beginPath();
        ctx.arc(sx, sy, rad, 0, 2*Math.PI);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  function drawVectorField(){
    if(!ui.showField.checked) return;

    const params = getParams();
    const mean = meanPosition();
    const typeMeans = meanByType();

    let mode = ui.fieldSelect.value;
    let type = 'red';
    let role = 'contractor';
    if(mode === 'red' || mode === 'green' || mode === 'blue'){
      type = mode;
      // show as a "typical" creature: contractor by default
      role = 'contractor';
    } else if(mode === 'rotator'){
      type = 'red';
      role = 'rotator';
    } else {
      type = 'red';
      role = 'contractor';
    }

    const gx = 18;
    const gy = 12;

    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 1.15 * DPR;

    for(let j=0; j<=gy; j++){
      for(let i=0; i<=gx; i++){
        const x = lerp(WORLD.xmin, WORLD.xmax, i/gx);
        const y = lerp(WORLD.ymin, WORLD.ymax, j/gy);

        // skip deep ocean for readability
        if(islandMask(x,y) < 0.36) continue;

        const d = driftAt(x, y, type, role, mean, typeMeans, params);
        const mag = Math.sqrt(d.x*d.x + d.y*d.y) + 1e-9;
        const scale = 0.09;
        const vx = d.x/mag * scale;
        const vy = d.y/mag * scale;

        const [sx, sy] = worldToScreen(x,y);
        const [sx2, sy2] = worldToScreen(x+vx, y+vy);

        // arrow
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx2, sy2);
        ctx.stroke();

        const ang = Math.atan2(sy2 - sy, sx2 - sx);
        const ah = 6 * DPR;
        ctx.beginPath();
        ctx.moveTo(sx2, sy2);
        ctx.lineTo(sx2 - ah*Math.cos(ang-0.55), sy2 - ah*Math.sin(ang-0.55));
        ctx.lineTo(sx2 - ah*Math.cos(ang+0.55), sy2 - ah*Math.sin(ang+0.55));
        ctx.closePath();
        ctx.fillStyle = 'rgba(255,255,255,0.40)';
        ctx.fill();
      }
    }

    // title badge
    ctx.globalAlpha = 1;
    const label = (() => {
      if(mode === 'red') return 'Field: red creature drift';
      if(mode === 'green') return 'Field: green creature drift';
      if(mode === 'blue') return 'Field: blue creature drift';
      if(mode === 'rotator') return 'Field: rotator drift';
      return 'Field: contractor drift';
    })();

    ctx.font = `${12*DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    const pad = 10*DPR;
    const tw = ctx.measureText(label).width;
    const x0 = 14*DPR;
    const y0 = (H - 14*DPR);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.lineWidth = 1*DPR;
    roundRect(ctx, x0, y0 - 24*DPR, tw + 2*pad, 20*DPR, 999*DPR);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(label, x0 + pad, y0 - 10*DPR);

    ctx.restore();
  }

  function roundRect(c, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawCenters(){
    if(!ui.showCenters.checked) return;
    const mean = meanPosition();

    ctx.save();
    ctx.globalAlpha = 1;

    // type centers
    for(const typ of TYPES){
      const c = centers[typ];
      const [sx, sy] = worldToScreen(c.x, c.y);

      ctx.fillStyle = typeColor[typ].fill;
      ctx.strokeStyle = 'rgba(0,0,0,0.45)';
      ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      ctx.arc(sx, sy, 7*DPR, 0, 2*Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.font = `${12*DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
      ctx.fillText(typ.toUpperCase(), sx + 10*DPR, sy - 10*DPR);
    }

    // mean marker
    {
      const [mx, my] = worldToScreen(mean.x, mean.y);
      ctx.strokeStyle = 'rgba(255,255,255,0.86)';
      ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      ctx.arc(mx, my, 8*DPR, 0, 2*Math.PI);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(mx - 10*DPR, my);
      ctx.lineTo(mx + 10*DPR, my);
      ctx.moveTo(mx, my - 10*DPR);
      ctx.lineTo(mx, my + 10*DPR);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.font = `${12*DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
      ctx.fillText('mean', mx + 12*DPR, my + 4*DPR);
    }

    ctx.restore();
  }

  function drawCreature(p){
    const [sx, sy] = worldToScreen(p.x, p.y);
    const col = typeColor[p.type].fill;
    const stroke = 'rgba(0,0,0,0.55)';

    // trail
    if(ui.showTrails.checked && p.trail.length >= 2){
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = typeColor[p.type].stroke;
      ctx.lineWidth = 2.2 * DPR;
      ctx.beginPath();
      for(let i=0;i<p.trail.length;i++){
        const q = p.trail[i];
        const [tx, ty] = worldToScreen(q.x, q.y);
        if(i===0) ctx.moveTo(tx, ty); else ctx.lineTo(tx, ty);
      }
      ctx.stroke();
      ctx.restore();
    }

    // body (simple "Pokemon-like" chubby creature)
    ctx.save();
    ctx.translate(sx, sy);

    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.beginPath();
    ctx.ellipse(0, 10*DPR, 10*DPR, 4.5*DPR, 0, 0, 2*Math.PI);
    ctx.fill();

    ctx.globalAlpha = 1;
    // ears
    ctx.fillStyle = col;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2*DPR;

    ctx.beginPath();
    ctx.moveTo(-7*DPR, -6*DPR);
    ctx.quadraticCurveTo(-14*DPR, -16*DPR, -5*DPR, -18*DPR);
    ctx.quadraticCurveTo(-2*DPR, -12*DPR, -7*DPR, -6*DPR);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(7*DPR, -6*DPR);
    ctx.quadraticCurveTo(14*DPR, -16*DPR, 5*DPR, -18*DPR);
    ctx.quadraticCurveTo(2*DPR, -12*DPR, 7*DPR, -6*DPR);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // body
    ctx.beginPath();
    ctx.arc(0, 0, 11*DPR, 0, 2*Math.PI);
    ctx.fill();
    ctx.stroke();

    // belly highlight
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(0, 3*DPR, 7*DPR, 6*DPR, 0, 0, 2*Math.PI);
    ctx.fill();
    ctx.globalAlpha = 1;

    // face
    ctx.fillStyle = 'rgba(0,0,0,0.80)';
    ctx.beginPath();
    ctx.arc(-4*DPR, -2*DPR, 1.7*DPR, 0, 2*Math.PI);
    ctx.arc(4*DPR, -2*DPR, 1.7*DPR, 0, 2*Math.PI);
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.75)';
    ctx.lineWidth = 1.4*DPR;
    ctx.beginPath();
    ctx.arc(0, 1.7*DPR, 3.0*DPR, 0.15*Math.PI, 0.85*Math.PI);
    ctx.stroke();

    // role badge
    if(p.isRot){
      // swirl
      ctx.strokeStyle = 'rgba(255,255,255,0.92)';
      ctx.lineWidth = 1.8*DPR;
      ctx.beginPath();
      ctx.arc(0, -15*DPR, 4.2*DPR, 0.25*Math.PI, 1.95*Math.PI);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(1.5*DPR, -15.5*DPR, 1.2*DPR, 0, 2*Math.PI);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.fill();
    } else {
      // small down arrow
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.beginPath();
      ctx.moveTo(0, -20*DPR);
      ctx.lineTo(-4*DPR, -14*DPR);
      ctx.lineTo(4*DPR, -14*DPR);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  }

  function render(){
    // background
    ctx.drawImage(bgCanvas, 0, 0);

    // overlays
    if(ui.showContours.checked) drawContours();
    drawVectorField();

    drawCenters();

    // particles
    for(const p of particles){
      drawCreature(p);
    }

    // header info
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(255,255,255,0.86)';
    ctx.font = `${13*DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    const status = running ? 'Running' : 'Paused';
    ctx.fillText(`${status} · steps: ${stepCount}`, 14*DPR, 22*DPR);
    ctx.restore();
  }

  // ---------- Hover probe ----------
  let mouse = {x:0, y:0, inside:false};
  canvas.addEventListener('mousemove', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const sx = (ev.clientX - rect.left) * DPR;
    const sy = (ev.clientY - rect.top) * DPR;
    mouse.x = sx; mouse.y = sy; mouse.inside = true;

    const [wx, wy] = screenToWorld(sx, sy);
    const params = getParams();
    const mean = meanPosition();
    const typeMeans = meanByType();

    // show field probe matching current fieldSelect
    let mode = ui.fieldSelect.value;
    let type = 'red';
    let role = 'contractor';
    if(mode === 'red' || mode === 'green' || mode === 'blue'){
      type = mode;
      role = 'contractor';
    } else if(mode === 'rotator'){
      role = 'rotator';
      type = 'red';
    } else {
      role = 'contractor';
      type = 'red';
    }

    const d = driftAt(wx, wy, type, role, mean, typeMeans, params);
    const speed = Math.sqrt(d.x*d.x + d.y*d.y);

    ui.hoverTip.style.left = `${ev.clientX}px`;
    ui.hoverTip.style.top = `${ev.clientY}px`;
    ui.hoverTip.style.display = 'block';
    ui.hoverTip.innerHTML = `
      <div><b>Probe</b> at $(${wx.toFixed(2)},\;${wy.toFixed(2)})$</div>
      <div style="margin-top:4px; opacity:0.9;">Drift: $(${d.x.toFixed(2)},\;${d.y.toFixed(2)})$ &nbsp;|&nbsp; $\|b(x)\|=${speed.toFixed(2)}$</div>
      <div style="margin-top:4px; opacity:0.85;">Mean: $(${mean.x.toFixed(2)},\;${mean.y.toFixed(2)})$</div>
    `;

    // request MathJax typeset for the tooltip only occasionally
    if(window.MathJax && window.MathJax.typesetPromise){
      window.MathJax.typesetPromise([ui.hoverTip]).catch(()=>{});
    }
  });
  canvas.addEventListener('mouseleave', () => {
    mouse.inside = false;
    ui.hoverTip.style.display = 'none';
  });

  // ---------- UI: collapse panels ----------
  const controls = document.getElementById('controls');
  const mathPanel = document.getElementById('math-panel');
  const statsPanel = document.getElementById('stats-panel');

  const controlsTab = document.getElementById('controlsTab');
  const mathTab = document.getElementById('mathTab');

  function hidePanel(panel, tab){
    panel.style.display = 'none';
    tab.style.display = 'flex';
  }
  function showPanel(panel, tab){
    panel.style.display = 'block';
    tab.style.display = 'none';
  }

  const openMathLink = document.getElementById('openMathLink');
  if(openMathLink){
    openMathLink.addEventListener('click', (e) => {
      // Works even if the panel is currently hidden behind its edge tab.
      e.preventDefault();
      showPanel(mathPanel, mathTab);
      mathPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
      // Ensure the ODE shown matches current toggles/sliders.
      updateMathEquation();
    });
  }


  document.getElementById('toggleControlsBtn').addEventListener('click', () => hidePanel(controls, controlsTab));
  controlsTab.addEventListener('click', () => showPanel(controls, controlsTab));

  document.getElementById('toggleMathBtn').addEventListener('click', () => hidePanel(mathPanel, mathTab));
  mathTab.addEventListener('click', () => showPanel(mathPanel, mathTab));

  document.getElementById('toggleStatsBtn').addEventListener('click', () => {
    if(statsPanel.style.display === 'none') statsPanel.style.display = 'block';
    else statsPanel.style.display = 'none';
  });

  // ---------- Buttons ----------
  ui.resetBtn.addEventListener('click', () => {
    resetParticles(ui.initSelect.value);
    running = false;
    ui.runBtn.textContent = 'Run';
    ui.runBtn.classList.add('cta');
  });

  ui.reseedBtn.addEventListener('click', () => {
    islandSeed = (Math.floor(rng()*1e9) ^ (Date.now() & 0xffffffff)) >>> 0;
    regenBackground();
    resetParticles(ui.initSelect.value);
    running = false;
    ui.runBtn.textContent = 'Run';
    ui.runBtn.classList.add('cta');
    flashTip(`<b>Reseeded island</b><br>Terrain regenerated with a new random seed.`);
  });

  ui.stepBtn.addEventListener('click', () => {
    stepOnce();
    render();
  });

  ui.runBtn.addEventListener('click', () => {
    running = !running;
    ui.runBtn.textContent = running ? 'Pause' : 'Run';
    if(running) ui.runBtn.classList.remove('cta');
    else ui.runBtn.classList.add('cta');
  });

  ui.loadPresetBtn.addEventListener('click', () => {
    loadPresetById(ui.presetSelect.value);
  });

  // ---------- Flash tip ----------
  let tipTimer = null;
  function flashTip(html){
    const tip = ui.hoverTip;
    tip.style.left = '14px';
    tip.style.top = '54px';
    tip.style.display = 'block';
    tip.style.transform = 'none';
    tip.innerHTML = html;
    if(window.MathJax && window.MathJax.typesetPromise){
      window.MathJax.typesetPromise([tip]).catch(()=>{});
    }
    clearTimeout(tipTimer);
    tipTimer = setTimeout(() => {
      if(!mouse.inside) tip.style.display = 'none';
      tip.style.transform = 'translate(12px, 12px)';
    }, 2800);
  }

  // ---------- Animation loop ----------
  function tick(){
    if(running){
      // do a few substeps for smoother motion if dt is large
      const params = getParams();
      const sub = params.dt > 0.045 ? 2 : 1;
      const oldDt = params.dt;
      if(sub > 1){
        // temporarily halve dt per substep
        const dtEl = ui.dtRange;
        const dtBak = dtEl.value;
        dtEl.value = (oldDt / sub).toFixed(3);
        for(let i=0;i<sub;i++) stepOnce();
        dtEl.value = dtBak;
        syncLabels();
      } else {
        stepOnce();
      }
    }
    render();
    requestAnimationFrame(tick);
  }

  // ---------- Init ----------
  function init(){
    populatePresets();
    resize();
    regenBackground();
    loadPresetById('p0');
    // small initial run to settle
    for(let i=0;i<10;i++) stepOnce();
    render();
    syncLabels();
    updateMathEquation();
    tick();
  }

  init();

})();
</script>
</body>
</html>