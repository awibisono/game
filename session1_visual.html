<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Solver View: Hessian Dynamics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { margin: 0; background: #000; color: #a7a9be; font-family: 'Courier New', monospace; overflow: hidden; }
        #canvas { display: block; cursor: crosshair; }
        
        /* UI Overlay */
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px; border-radius: 4px; border-left: 3px solid #00ffff;
            max-width: 350px; z-index: 10;
            backdrop-filter: blur(5px);
        }
        h1 { margin: 0 0 5px 0; color: #00ffff; font-size: 1.1rem; }
        .math { font-style: italic; color: #ff00ff; margin-bottom: 10px; font-size: 0.85rem; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 3px; font-size: 0.8rem; }
        .val { color: #fff; font-weight: bold; }

        /* God Panel */
        #god-panel {
            display: none;
            position: absolute; top: 20px; right: 20px;
            background: rgba(10, 10, 15, 0.9);
            padding: 15px; border: 1px solid #444; border-top: 3px solid #00ffff;
            border-radius: 4px; width: 300px; max-height: 90vh; overflow-y: auto;
            z-index: 20;
        }
        .god-header { color: #fff; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        
        .control-group { margin-bottom: 10px; }
        label { display: block; font-size: 0.75rem; color: #aaa; margin-bottom: 3px; }
        select, input[type=range], button { width: 100%; background: #222; color: #ddd; border: 1px solid #444; padding: 4px; font-size: 0.8rem; }
        input[type=checkbox] { width: auto; margin-right: 5px; }
        button:hover { background: #333; border-color: #00ffff; color: #fff; }

        /* Stats Panels */
        #charts-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; gap: 10px; z-index: 15;
            pointer-events: none;
        }
        .chart-box {
            background: rgba(0, 0, 0, 0.8); border: 1px solid #333; padding: 10px;
            width: 300px; height: 160px; pointer-events: auto;
        }
        .chart-title { font-size: 0.7rem; color: #aaa; margin-bottom: 5px; border-bottom: 1px solid #222; }

        /* Unlock Controls */
        #unlock-pad {
            position: absolute; bottom: 20px; right: 20px;
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;
            z-index: 10;
        }
        #unlock-pad button { width: 40px; height: 40px; font-weight: bold; }

    </style>
</head>
<body>
    <div id="ui">
        <h1>Mean Field Dynamics</h1>
        <div class="math">dX_t = -âˆ‡V(X_t)dt - âˆ‡W*Î¼_t(X_t)dt + ÏƒdB_t</div>
        <div class="stat-row"><span>Time T:</span> <span id="time-val" class="val">0.00</span></div>
        <div class="stat-row"><span>Mean Energy E[V]:</span> <span id="mean-e" class="val">0</span></div>
        <div class="stat-row"><span>Entropy S:</span> <span id="entropy" class="val">0</span></div>
    </div>

    <!-- God View Panel -->
    <div id="god-panel">
        <div class="god-header">ðŸ¦‰ THE SOLVER VIEW</div>
        
        <div class="control-group">
            <label>Population (N): <span id="val-n">50</span></label>
            <input type="range" id="slider-n" min="10" max="200" step="10" value="50">
        </div>

        <div class="control-group">
            <label>Drift Potential V(x)</label>
            <select id="sel-v">
                <option value="quadratic">Quadratic (Gravity)</option>
                <option value="double_well">Double-Well (Bifurcation)</option>
                <option value="rastrigin">Rastrigin (Multi-modal)</option>
                <option value="rosenbrock">Rosenbrock (Valley)</option>
                <option value="flat">Zero (Brownian)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Interaction Kernel W(x-y)</label>
            <select id="sel-w">
                <option value="coulomb">Coulomb (Repulsion)</option>
                <option value="newtonian">Newtonian (Attraction)</option>
                <option value="morse">Swarm (Bio)</option>
                <option value="none">Zero (Independent)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Noise (Sigma): <span id="val-sigma">0.5</span></label>
            <input type="range" id="slider-noise" min="0" max="5" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Step Size (dt): <span id="val-dt">0.1</span></label>
            <input type="range" id="slider-dt" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Sim Speed (Delay ms)</label>
            <input type="range" id="slider-speed" min="0" max="100" step="5" value="0">
        </div>
        
        <div class="control-group">
            <label><input type="checkbox" id="chk-field"> Show Gradient Field (âˆ‡V)</label>
            <label><input type="checkbox" id="chk-contour" checked> Show Potential Heatmap</label>
            <label><input type="checkbox" id="chk-history"> Show Trajectories</label>
        </div>
    </div>

    <!-- Charts -->
    <div id="charts-container">
        <div class="chart-box">
            <div class="chart-title">SYSTEM STATISTICS</div>
            <canvas id="sys-chart"></canvas>
        </div>
        <div class="chart-box" id="agent-box" style="display:none;">
            <div class="chart-title">AGENT <span id="insp-id">#</span> ENERGY</div>
            <canvas id="agent-chart"></canvas>
        </div>
    </div>

    <div id="unlock-pad">
        <div></div>
        <button onclick="checkUnlock('north')">N</button>
        <div></div>
        <button onclick="checkUnlock('west')">W</button>
        <button onclick="checkUnlock('south')">S</button>
        <button onclick="checkUnlock('east')">E</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- GOD MODE UNLOCK ---
        let unlockSequence = [];
        const correctSequence = ['north', 'south', 'west', 'east'];

        function checkUnlock(action) {
            unlockSequence.push(action);
            if (unlockSequence.length > 4) unlockSequence.shift();
            if (JSON.stringify(unlockSequence) === JSON.stringify(correctSequence)) {
                document.getElementById('god-panel').style.display = 'block';
                document.getElementById('unlock-pad').style.display = 'none'; // Hide buttons after unlock
            }
        }

        // --- SIMULATION ENGINE ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // State
        let N = 50;
        let dt = 0.1;
        let sigma = 0.5;
        let vType = 'quadratic';
        let wType = 'coulomb';
        let delay = 0;
        let time = 0;
        
        let agents = [];
        let selectedAgent = null;
        let sysChart, agentChart;
        let sysHistory = { meanE: [], entropy: [] };
        
        const COLORS = ["#ff8906", "#e53170", "#f25f4c", "#a7a9be", "#2cb67d"];

        // Initialization
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function initAgents() {
            agents = [];
            for(let i=0; i<N; i++) {
                agents.push({
                    id: i,
                    x: (Math.random() - 0.5) * width/3 + width/2, 
                    y: (Math.random() - 0.5) * height/3 + height/2,
                    vx: 0, vy: 0,
                    type: i % 5,
                    history: [],
                    energyLog: []
                });
            }
            if(selectedAgent >= N) selectedAgent = null; 
        }

        // --- MATH HELPERS ---
        function getV(x, y) {
            const cx = width/2, cy = height/2;
            const dx = (x - cx)/100; 
            const dy = (y - cy)/100;
            
            if (vType === 'quadratic') return 0.5 * (dx*dx + dy*dy);
            if (vType === 'double_well') return 0.25 * Math.pow(dx*dx - 4, 2) + 0.5*dy*dy; 
            if (vType === 'rastrigin') return 20 + (dx*dx - 10*Math.cos(2*Math.PI*dx)) + (dy*dy - 10*Math.cos(2*Math.PI*dy));
            if (vType === 'rosenbrock') return Math.pow(1-dx, 2) + 10*Math.pow(dy - dx*dx, 2);
            return 0; 
        }

        function getGradV(x, y) {
            const h = 1.0; // Finite difference step
            const v0 = getV(x, y);
            const vx = getV(x + h, y);
            const vy = getV(x, y + h);
            return { x: (vx - v0)/h, y: (vy - v0)/h };
        }

        function getGradW(rx, ry) {
            const r2 = rx*rx + ry*ry;
            const r = Math.sqrt(r2);
            if (r < 5) return {x:0, y:0}; // Soft core

            let mag = 0;
            if (wType === 'coulomb') mag = 2000 / (r2 * r); 
            if (wType === 'newtonian') mag = -0.5; 
            if (wType === 'morse') mag = -20 * (Math.exp(-r/50) - Math.exp(-r/20)); 
            
            return { x: rx * mag, y: ry * mag };
        }

        // --- UPDATE ---
        function update() {
            let meanE = 0;
            
            for(let i=0; i<N; i++) {
                let a = agents[i];
                
                // Forces
                let gradV = getGradV(a.x, a.y);
                let fx = -gradV.x;
                let fy = -gradV.y;

                if (wType !== 'none') {
                    let ix=0, iy=0;
                    for(let j=0; j<N; j++) {
                        if(i===j) continue;
                        let gw = getGradW(a.x - agents[j].x, a.y - agents[j].y);
                        ix += gw.x; iy += gw.y;
                    }
                    fx += ix / N;
                    fy += iy / N;
                }

                // Noise
                fx += (Math.random() - 0.5) * sigma * 20;
                fy += (Math.random() - 0.5) * sigma * 20;

                // Move
                a.vx = fx; a.vy = fy;
                a.x += a.vx * dt;
                a.y += a.vy * dt;

                // Bounds
                if(a.x < 0 || a.x > width) { a.x = Math.max(0, Math.min(width, a.x)); a.vx *= -1; }
                if(a.y < 0 || a.y > height) { a.y = Math.max(0, Math.min(height, a.y)); a.vy *= -1; }

                // History
                if(time % 1 < dt*1.5) { // Roughly every integer second
                     a.history.push({x: a.x, y: a.y});
                     if(a.history.length > 50) a.history.shift();
                }

                // Stats
                let pot = getV(a.x, a.y);
                meanE += pot;
                a.energyLog.push(pot);
                if(a.energyLog.length > 100) a.energyLog.shift();
            }

            // Global Stats
            time += dt;
            document.getElementById('time-val').innerText = time.toFixed(2);
            document.getElementById('mean-e').innerText = (meanE / N).toFixed(2);
            
            // Entropy (Grid)
            let grid = new Array(100).fill(0);
            agents.forEach(a => {
                let gx = Math.floor(a.x / (width/10));
                let gy = Math.floor(a.y / (height/10));
                if(gx>=0 && gx<10 && gy>=0 && gy<10) grid[gy*10+gx]++;
            });
            let entropy = 0;
            grid.forEach(c => { if(c > 0) { let p = c/N; entropy -= p * Math.log(p); } });
            document.getElementById('entropy').innerText = entropy.toFixed(3);

            // Chart Updates
            sysHistory.meanE.push(meanE / N);
            sysHistory.entropy.push(entropy);
            if(sysHistory.meanE.length > 100) { sysHistory.meanE.shift(); sysHistory.entropy.shift(); }
        }

        // --- RENDER ---
        function drawVectorField() {
            if(!document.getElementById('chk-field').checked) return;
            
            const step = 40;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
            ctx.lineWidth = 1;
            
            for(let x=0; x<width; x+=step) {
                for(let y=0; y<height; y+=step) {
                    let g = getGradV(x, y);
                    let mag = Math.hypot(g.x, g.y);
                    if(mag < 0.01) continue;
                    
                    let dx = (g.x / mag) * 15; // Normalize for display
                    let dy = (g.y / mag) * 15;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - dx, y - dy); // Draw negative gradient (flow direction)
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(x - dx, y - dy, 1, 0, Math.PI*2);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.fill();
                }
            }
        }

        function drawContour() {
            if(!document.getElementById('chk-contour').checked) {
                ctx.fillStyle = '#0f0e17';
                ctx.fillRect(0,0,width,height);
                return;
            }
            
            // Generate Heatmap
            const res = 10; // Pixel size
            for(let x=0; x<width; x+=res) {
                for(let y=0; y<height; y+=res) {
                    let v = getV(x + res/2, y + res/2);
                    // Color mapping: Purple (low) -> Blue -> Teal -> Green (High)
                    let t = Math.min(1, v / 50); // Normalize roughly
                    let r = Math.floor(20 + t * 40);
                    let g = Math.floor(10 + t * 80);
                    let b = Math.floor(40 + t * 60);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, res, res);
                }
            }
        }

        function draw() {
            drawContour();
            drawVectorField();

            const showHist = document.getElementById('chk-history').checked;

            for(let i=0; i<N; i++) {
                let a = agents[i];
                
                // Trajectory
                if(showHist && a.history.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = COLORS[a.type];
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.5;
                    ctx.moveTo(a.history[0].x, a.history[0].y);
                    for(let p of a.history) ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }

                // Agent
                ctx.beginPath();
                ctx.arc(a.x, a.y, 5, 0, Math.PI*2);
                ctx.fillStyle = COLORS[a.type];
                
                if(selectedAgent === i) {
                    ctx.shadowBlur = 15; ctx.shadowColor = "#fff";
                    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
                } else {
                    ctx.shadowBlur = 0;
                }
                
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // --- CHARTS ---
        function initCharts() {
            const commonOpts = { 
                responsive: true, animation: false, 
                elements: { point: { radius: 0 } },
                scales: { x: { display: false }, y: { display: true, grid: { color: '#333' } } },
                plugins: { legend: { display: false } }
            };

            // Sys Chart
            sysChart = new Chart(document.getElementById('sys-chart'), {
                type: 'line',
                data: { 
                    labels: Array(100).fill(''), 
                    datasets: [
                        { label: 'Mean Energy', data: [], borderColor: '#ff00ff', borderWidth: 1 },
                        { label: 'Entropy', data: [], borderColor: '#00ffff', borderWidth: 1 }
                    ] 
                },
                options: commonOpts
            });

            // Agent Chart
            agentChart = new Chart(document.getElementById('agent-chart'), {
                type: 'line',
                data: { 
                    labels: Array(100).fill(''), 
                    datasets: [{ label: 'V(X)', data: [], borderColor: '#ffff00', borderWidth: 1 }] 
                },
                options: commonOpts
            });
        }

        function updateCharts() {
            if(sysChart) {
                sysChart.data.datasets[0].data = sysHistory.meanE;
                sysChart.data.datasets[1].data = sysHistory.entropy;
                sysChart.update('none');
            }
            if(selectedAgent !== null && agentChart) {
                agentChart.data.datasets[0].data = agents[selectedAgent].energyLog;
                agentChart.update('none');
            }
        }

        // --- LOOP ---
        function loop() {
            update();
            draw();
            if(step % 5 === 0) updateCharts();
            step++;
            setTimeout(() => requestAnimationFrame(loop), delay);
        }

        // --- INPUTS ---
        document.getElementById('slider-n').addEventListener('input', e => { N = parseInt(e.target.value); document.getElementById('val-n').innerText = N; initAgents(); });
        document.getElementById('sel-v').addEventListener('change', e => vType = e.target.value);
        document.getElementById('sel-w').addEventListener('change', e => wType = e.target.value);
        document.getElementById('slider-noise').addEventListener('input', e => { sigma = parseFloat(e.target.value); document.getElementById('val-sigma').innerText = sigma; });
        document.getElementById('slider-dt').addEventListener('input', e => { dt = parseFloat(e.target.value); document.getElementById('val-dt').innerText = dt; });
        document.getElementById('slider-speed').addEventListener('input', e => delay = parseInt(e.target.value));

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            let closest = -1, minD = 1000;
            for(let i=0; i<N; i++) {
                let d = Math.hypot(agents[i].x - mx, agents[i].y - my);
                if(d < 30 && d < minD) { minD = d; closest = i; }
            }
            if(closest !== -1) {
                selectedAgent = closest;
                document.getElementById('agent-box').style.display = 'block';
                document.getElementById('insp-id').innerText = closest;
            } else {
                selectedAgent = null;
                document.getElementById('agent-box').style.display = 'none';
            }
        });

        initAgents();
        initCharts();
        loop();

    </script>
</body>
</html>